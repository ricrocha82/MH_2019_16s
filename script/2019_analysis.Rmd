---
title: "Microbial Community 2019 Analysis"
author: "Ricardo Silva"
date: "02/06/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval=FALSE, 
                      message=FALSE, 
                      warning=FALSE)
```

```{r CLEAR EVERYTHING, eval=FALSE, include=FALSE}
# unload all non-base packages
lapply(names(sessionInfo()$otherPkgs), function(pkgs)
  detach(
    paste0('package:', pkgs),
    character.only = T,
    unload = T,
    force = T
))

rm(list=ls())
```

# Packages and initial steps

```{r load libraries, message=FALSE, warning=FALSE, include=FALSE}
# load the packages
# main packs to start with
pcks <- c('phyloseq', 'microbiome','microbiomeutilities' ,'vegan', 'factoextra',"FactoMineR", "patchwork",'corrr','GGally','tidymodels',"ggforce", 'tidyverse')

if(sum(as.numeric(!pcks %in% installed.packages())) != 0){
  installation <- pcks[!pcks %in% installed.packages()]
  for(i in 1:length(installation)) {
    install.packages(installation, dependencies = T)
    break()}
  suppressPackageStartupMessages(
  sapply(pcks,require,character.only = T)
) 
} else {
  suppressPackageStartupMessages(
  sapply(pcks,require,character.only = T)
) 
}

rm(pcks)
```

```{r packages and functions}
# set working directory and seed
setwd("~R/git_hub/MH_2019/data")
folder_path <- "~R/git_hub/MH_2019/output/"

source('~/R/git_hub/MH_2019/script/my_functions.R')
source('~/R/git_hub/MH_2019/script/theme_publication.R')
theme_set(theme_Publication_3())

# set colors
color_distance <- c("D0" = "deepskyblue2", 'D1' = 'brown1',  "D2" = "forestgreen", "D3" = "#440154FF", "D4" = "burlywood")
# color_distance1 <- c('D1' = 'brown1',  "D2" = "forestgreen", "D3" = "#440154FF", "D4" = "burlywood")
color_depth <- c('DP1'="darkorange",'DP2'="purple", "DP3" = "cyan4")
cage_control <- friendly_cols

# check the working directory
current_directory <- getwd()
paste("Working in directory:", current_directory)
```

# Aims

Asses bacterial community and function changes and check if 16S and functional profiling can predict nutrient concentrations

Here, we characterized how fish farms affect the spatial distribution of marine microorganisms and bacterial functions in a semi-enclosed coastal environment, tested how similar the spatial niche of closely related taxa is, and what are the environmental parameters modulating their spatial abundance patterns.

We collected surface seawater samples (at a depth of 50 cm) in fish-net cages (29° 32′20” N, 121° 45′10” E, with suffix “F”) and an adjacent control site (29°36′4” N, 121° 46′10” E, 7 km apart from the fish-net cages, with suffix “C”)

# Load Data 

```{r}
# load object in RData format
# 16S
# load("pseq.list.RData")
load("pseq.list.filt.RData") # filtered data
# load("pseq.list.clr.RData") # clr transformed data

# picrust
# load("pseq.fun.RData")
load("pseq.func.filt.RData") # filtered data
# load("pseq.func.clr.RData") # clr transformed data

# meta
meta <- read_csv(paste0(getwd(),"/meta.csv")) 

# dir.create(paste0(folder_path, "data/feature_selection"))
# dir.create(paste0(folder_path, "plots/feature_selection"))

```


## Map - Sampling Sites

```{r}
# map_depth_profile.Rmd
```

## Environmental variables

### Tables and Plots

```{r explore env factors}
# variables to analyze
env.var <- c('conductivity', 'oxygen', 'salinity','temperature','PAR', 'fluorescence', 'turbidity')
nuts <- c('NH4','NOX','NO2',"PO4")


# using GGally package

discrete_palettes <- list(
  c("skyblue", "orange"),
  RColorBrewer::brewer.pal(10, "Set2"),
  RColorBrewer::brewer.pal(10, "Accent")
)

# nutrients and env factors
col_ggally <- meta %>% select(Distance_m, Depth_m, env.var) %>% 
  relocate(Distance_m, Depth_m) %>% names
# by depth
ggally_depth <- meta %>%
  select(Depth, col_ggally) %>% 
  ggpairs(aes(color = Depth),
          columns = col_ggally,
          lower = list(continuous = "smooth")
          )  +
  scale_colour_manual(values = c("darkorange","purple","cyan4")) +
  scale_fill_manual(values = c("darkorange","purple","cyan4"))

ggsave(paste0(folder_path,"plots/meta/meta_ggally_depth.tiff"), ggally_depth, width = 15, height = 10 ,device = "tiff", compression = "lzw")

# by distance
ggally_distance <- meta %>%
  select(Distance, Distance_m, Depth_m, NH4:PO4) %>% 
  ggpairs(aes(color = Distance), alpha = 0.5,
          columns = names(select(.,-Distance))
          )  +
  scale_colour_manual(values = c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854" )) +
  scale_fill_manual(values = c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854" ))

ggsave(paste0(folder_path,"plots/meta/meta_ggally_distance.tiff"), ggally_distance , width = 15, height = 10, device = "tiff", compression = "lzw")


# Plot Matrix Subsetting
map(3:6,~ggally_distance[.,2] + 
              scale_x_reverse() + 
              coord_flip() +
      geom_smooth(se=F, method = "lm"))

```


### summary tables

```{r env factors summary tables}
# variables to analyze
env.var <- c('conductivity', 'oxygen', 'salinity','temperature','PAR', 'fluorescence', 'turbidity')
nuts <- c('NH4','NOX','NO2',"PO4")

# Summary 
# Environmental data
meta_long <- meta %>% 
              select(site, Distance, Depth, all_of(env.var), all_of(nuts)) %>%
              pivot_longer(names_to="env_par", values_to="value", -c(site, Distance, Depth)) 

meta_summary <- meta_long %>% group_by(site, Distance, Depth, env_par) %>%
                      summarise(mean= paste(round(mean(value),2),"±",round(sd(value),2)), 
                                min_max = paste(round(min(value),1),"-",round(max(value),1)))

meta_summary.env <- meta_summary %>% 
                      filter(env_par %in% env.var) %>% 
                      pivot_wider(c(site, Distance, Depth), 
                                  env_par, 
                                  values_from = c(mean, min_max))

meta_summary.nuts <- meta_summary %>% 
                      filter(env_par %in% nuts) %>% 
                       pivot_wider(c(site, Distance, Depth), 
                                  env_par, 
                                  values_from = c(mean, min_max))

# save as csv
write.csv(meta_summary.env , paste0(folder_path,"data/env/meta_summary_env_site.csv"))
write.csv(meta_summary.nuts, paste0(folder_path,"data/env/meta_summary_nuts_site.csv"))

```

### Depth and Distance profiles

#### Depth

```{r depth profile}
# DEPTH

# NUTRIENTS
# cages and control
depth_profile_plot_1 <- meta %>%  
        select(NH4:PO4, Depth_m, site) %>% 
     #   mutate(Depth = fct_relevel(Depth, c("DP3", "DP2", 'DP1'))) %>%
        pivot_longer(names_to="env_par", values_to="value", -c(Depth_m, site)) %>%
        group_by(Depth_m, site, env_par) %>%
        summarise(mean= mean(value), sd= sd(value), max = max(value),min = min(value)) %>%
        ggplot(aes(x= Depth_m, y = mean, group = interaction(env_par, site))) + 
        geom_line(aes(linetype = site, color = site)) + 
        geom_point(aes(color = site), alpha = 0.5) +
        labs(y = NULL, x = "Depth (m)") +
        scale_x_reverse() +
        geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd, color = site), width = .1, alpha= 0.4) + 
        facet_wrap(~env_par, scales = 'free_x') +
        coord_flip() +
        scale_color_manual(values = c(cage_control)) +
        theme_depth_profile()
       
ggsave(paste0(folder_path,"plots/meta/depth_cage_control_nutrients.tiff"), depth_profile_plot_1, device = "tiff", compression = "lzw")

# ENV FACTORS
# Lease and control
depth_profile_env <- meta %>% 
    #    mutate(Depth = fct_relevel(Depth, c("DP3", "DP2", 'DP1'))) %>%
        select(conductivity:turbidity, Depth_m, site) %>%
        pivot_longer(!c(Depth_m, site), 
                     names_to = 'env_par',values_to = 'value' ) %>%
        group_by(Depth_m, site, env_par) %>%
        summarise(mean= mean(value), sd= sd(value), max = max(value),min = min(value)) %>%
        # plot
        ggplot(aes(x= Depth_m, y = mean, group = interaction(env_par, site))) + 
        geom_line(aes(linetype = site, color = site)) + 
        geom_point(aes(color = site), alpha = 0.5) +
        labs(y = NULL) +
        geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd), width = .1, alpha= 0.4) + 
        facet_wrap(~env_par, scales = 'free_x') +
         scale_x_reverse() +
        coord_flip() +
        scale_color_manual(values = c(cage_control)) +
        theme_depth_profile()
  
ggsave(paste0(folder_path,"plots/meta/depth_cage_control_env.tiff"), depth_profile_env, device = "tiff", compression = "lzw")

p.depth_profile <- (depth_profile_plot_1 + theme(legend.position = "bottom")) + depth_profile_env  + theme(legend.position = "none") 

ggsave(paste0(folder_path,"plots/meta/depth_cage_control.tiff"), p.depth_profile, device = "tiff", compression = "lzw")

```


#### Distance
```{r line distance}
meta_lease1 <- read_csv(paste0(getwd(),"/meta_lease1.csv"))
meta_lease2 <- read_csv(paste0(getwd(),"/meta_lease2.csv"))

# Lease 1
# NUTS
nuts_lease1 <- meta_lease1 %>% 
  select(NH4:PO4, Distance_m, Depth, site) %>%
    mutate(Distance_m = as.factor(Distance_m)) %>%
  pivot_longer(!c('Distance_m', 'Depth', site), 
               names_to = 'env_par',values_to = 'value' ) %>%
  ggplot(aes(x= Distance_m, y = value, group= Depth)) + 
  geom_line(aes(linetype = Depth, color = Depth)) +
  geom_point(aes(color = Depth), alpha = 0.4, position = position_jitterdodge(dodge.width = 0.1)) +
#  geom_smooth(aes(color = Depth), se = F) +
  geom_vline(xintercept = '82.8', linetype="dashed", color = "red") +
  labs(y = NULL,
       x = "Distance (m)") +
#  geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd), width = .1, alpha= 0.1) + 
  facet_wrap(~env_par, scales = 'free_y') +
  scale_color_manual(labels = unique(meta$Depth1), values = c(color_depth)) +
  scale_linetype_manual(labels = unique(meta$Depth1), values = c(17, 15, 18)) +
  theme_depth_profile()

# ENV Par
env_lease1 <- meta_lease1 %>% 
  select(conductivity:turbidity,  Distance_m, Depth, -PAR, site) %>%
      mutate(Distance_m = as.factor(Distance_m)) %>%
  pivot_longer(!c('Distance_m', 'Depth', site), 
               names_to = 'env_par',values_to = 'value' ) %>%
  ggplot(aes(x= Distance_m, y = value, group= Depth)) + 
  geom_line(aes(linetype = Depth, color = Depth)) +
  geom_point(aes(color = Depth), alpha = 0.4, position = position_jitterdodge(dodge.width = 0.1)) +
#  geom_smooth(aes(color = Depth), se = F) +
  geom_vline(xintercept = '82.8', linetype="dashed", color = "red") +
  labs(y = NULL,
       x = "Distance (m)") +
#  geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd), width = .1, alpha= 0.1) + 
  facet_wrap(~env_par, scales = 'free_y', nrow = 3) +
  scale_color_manual(labels = unique(meta$Depth1), values = c(color_depth)) +
  scale_linetype_manual(labels = unique(meta$Depth1), values = c(17, 15, 18)) +
  theme_depth_profile()

# Lease 2
# NUTS
nuts_lease2 <- meta_lease2 %>% 
  select(NH4:PO4, Distance_m, Depth, site) %>%
    mutate(Distance_m = round(Distance_m, 1),
           Distance_m = as.factor(Distance_m)) %>%
  pivot_longer(!c('Distance_m', 'Depth', site), 
               names_to = 'env_par',values_to = 'value' ) %>%
  ggplot(aes(x= Distance_m, y = value, group= Depth)) + 
  geom_line(aes(linetype = Depth, color = Depth)) +
  geom_point(aes(color = Depth), alpha = 0.4, position = position_jitterdodge(dodge.width = 0.1)) +
#  geom_smooth(aes(color = Depth), se = F) +
  geom_vline(xintercept = '84.2', linetype="dashed", color = "red") +
  labs(y = NULL,
       x = "Distance (m)") +
#  geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd), width = .1, alpha= 0.1) + 
  facet_wrap(~env_par, scales = 'free_y') +
  scale_color_manual(labels = unique(meta$Depth1), values = c(color_depth)) +
  scale_linetype_manual(labels = unique(meta$Depth1), values = c(17, 15, 18)) +
  theme_depth_profile()

# ENV Par
env_lease2 <- meta_lease2 %>% 
  select(conductivity:turbidity,  Distance_m, Depth, -PAR, site) %>%
      mutate(Distance_m = round(Distance_m, 1),
           Distance_m = as.factor(Distance_m)) %>%
  pivot_longer(!c('Distance_m', 'Depth', site), 
               names_to = 'env_par',values_to = 'value' ) %>%
  ggplot(aes(x= Distance_m, y = value, group= Depth)) + 
  geom_line(aes(linetype = Depth, color = Depth)) +
  geom_point(aes(color = Depth), alpha = 0.4, position = position_jitterdodge(dodge.width = 0.1)) +
#  geom_smooth(aes(color = Depth), se = F) +
  geom_vline(xintercept = '84.2', linetype="dashed", color = "red") +
  labs(y = NULL,
       x = "Distance (m)") +
#  geom_errorbar(aes(ymin = mean - sd, ymax = mean +sd), width = .1, alpha= 0.1) + 
  facet_wrap(~env_par, scales = 'free_y', nrow = 3) +
  scale_color_manual(labels = unique(meta$Depth1), values = c(color_depth)) +
  scale_linetype_manual(labels = unique(meta$Depth1), values = c(17, 15, 18)) +
  theme_depth_profile()


pall_1 <- nuts_lease1/env_lease1 + plot_layout(guides = "collect") + plot_annotation(title = "Lease 1") & theme(legend.position = "bottom") 
pall_2 <- nuts_lease2/env_lease2 + plot_layout(guides = "collect") + plot_annotation(title = "Lease 2") & theme(legend.position = "bottom") 

ggsave(paste0(folder_path,"plots/meta/distance_profile_lease1.tiff"), pall_1 , device = "tiff", compression = "lzw")

ggsave(paste0(folder_path,"plots/meta/distance_profile_lease2.tiff"), pall_2, device = "tiff", compression = "lzw")
```


```{r clean R env}
rm(list = setdiff(ls(), c('folder_path','color_distance','color_depth','cage_control','pseq.list','meta', 'env.var',"nuts", "pseq.fun")))
source('~/R/git_hub/MH_2019/script/my_functions.R')
source('~/R/git_hub/MH_2019/script/theme_publication.R')
```

### Correlation

To avoid collinearity: Analyze correlation among environmental parameters. If there is, combine values into one parameter for downstream analysis. (r > 0.7, P ≤ 0.05). 

```{r env factor correlation}
# variables to analyze
env.var <- c('conductivity', 'oxygen', 'salinity','temperature','PAR', 'fluorescence', 'turbidity')
nuts <- c('NH4','NOX','NO2',"PO4")

# check to see if any variables are autocorrelated
meta.cor <- meta %>% 
  select(sample_id, all_of(c(env.var, nuts)))

# correlation
cor.tidy <- meta.cor %>%                # Create correlation data frame (cor_df).
  select(-sample_id) %>%
  correlate(method = 'spearman') %>%    # => Spearman for non-normal distributions
  rearrange() %>%                      # rearrange by correlations
  shave()                              # Shave off the upper triangle for a clean result

meta.cor %>%
# group_by(sample_id) %>%
  summarise(cor = cor(Chao1_Archaea, Chao1_Bacteria))

cor.df <- meta.cor %>%
  select(-sample_id) %>%
  as.matrix() %>%
  Hmisc::rcorr(type = "spearman") %>%
  broom::tidy() %>%
  mutate(sig = ifelse(p.value <= 0.05, "Sig", "Non Sig")) %>%
  filter(sig == "Sig" & estimate > 0.7)

corr <- round(cor(meta.cor %>% select(-sample_id), method = 'spearman'), 2)
p.mat <- ggcorrplot::cor_pmat(meta.cor %>% select(-sample_id))

cor_plot <- ggcorrplot::ggcorrplot(corr,
                                   p.mat = p.mat, 
                                   hc.order = TRUE, 
                                   insig = "blank",
                                   type = "lower",
                                   outline.col = "white", 
                                   colors = c("#6D9EC1", "white", "#E46726"),
                                   lab= T) + 
  theme_Publication_3() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title = element_blank()) 

cor_plot %>% ggsave(filename = paste0(folder_path, "plots/meta/correlation.tiff"), compression = "lzw")

# autocorrelated variables
# NOX, conductivity, salinity, temperature and PO4
# NO2 and NH4
# oxygen, PAR and fluorescence 

# variables selected = NOX, NH4 and oxygen


```


```{r clean env}
rm(list = setdiff(ls(), c('folder_path','color_distance','color_depth','cage_control','pseq.list',"meta", "pseq.fun")))
source('~/R/git_hub/MH_2019/script/my_functions.R')
source('~/R/git_hub/MH_2019/script/theme_publication.R')
```

 # EDA: Cluster and PCA

Exploratory data analysis: Cluster and PCA (prior to EDA -> transform the data). 
Before the PCA, data were log transformed if the distribution was skewed. 

PERMANOVA: to determine how both distance from cage and depth influence the microbial community

### PCA and k-mean

```{r env factors - PCA}
# variables to analyze
env.var <- c('conductivity', 'oxygen', 'salinity','temperature','PAR', 'fluorescence', 'turbidity')
nuts <- c('NH4','NOX','NO2',"PO4")

# get meta data
# meta <- pseq.list[[1]] %>% get_tibble("sam_data", column_id = "sample_id") %>%
#   select(-Distance_m, -Depth_m)

meta <- meta %>% rownames_to_column("sample_id") %>% as_tibble()

# variables to analyze
# env.pca <- c('oxygen', 'turbidity')
# nuts.pca <- c('NH4','NOX')

meta.pca <- meta %>% select(sample_id, Type,  dist_depth, Distance, Depth, site, Cag_Cont, all_of(env.var), all_of(nuts))
# prepare the data for PCA
# metaPCA <- meta %>% 
#   select(sample_id, Type,  dist_depth, Distance, Depth, Cag_Cont, 
#          all_of(c(env.pca, nuts.pca, div.pca))) # remove the columns that are autocorrelated 

# 1 - recipe - no values computed 
# Write recipe for PCA
pca_rec <- recipe(~., data = meta.pca) %>% # ~. because it is unsupervised
# Specify character_code as key/id column
  update_role(sample_id, Type,  dist_depth, Distance, Depth, site, Cag_Cont, new_role = 'id') %>% 
# Removes variables that have large absolute correlations with other variables
  step_corr(all_predictors(), threshold = 0.7, method = "spearman") %>% 
# normalize the data (center and scale all predictors (mean to zero and standard deviation of one)
#  step_log(all_predictors()) %>%
  step_normalize(all_predictors()) %>%
# PCA is done here
# can use threshold to specify if we want to capture 90% of variance in the data (threshold = 0.9)
  step_pca(all_predictors(), id = "pca") 

# 2 prep the recipe - values computed (prep() implements the recipe)
pca_prep <- prep(pca_rec) 

# variance bar plot (variance explained)
total_variance_plot <- pca_prep %>%
  tidy(id = 'pca', type = 'variance') %>%
  dplyr::filter(terms == 'percent variance') %>%
  ggplot(aes(x = component, y = value)) +
  geom_col(fill = "lightblue") +
  # xlim(c(0,5))+
  labs(y = '% of total variance')

# most contributing variables (PCA loadings)
tidied_pca <-  tidy(pca_prep, 3) # gives for every PC computed the value for each term(predictor) = Scores
# it can be notice that Nox and NH4 in the first component are closer but in opposite direction which means
# that they tend to not occur in the same sample. 
# Opposite direction means that the predictors tend to occur separately and vice versa.
pred_pca_env_factors <- tidied_pca %>% 
  #filter(component %in% paste0('PC',1:4)) %>% # first three components 
  group_by(component) %>% 
  #top_n(8, abs(value)) %>%
  ungroup() %>%
  mutate(terms = tidytext::reorder_within(terms, abs(value), component)) %>%
  ggplot(aes(abs(value), terms, fill = value > 0 )) +
  geom_col() +
  tidytext::scale_y_reordered() +
  scale_fill_manual(values = c("#b6dfe2", "#0A537D")) +
  facet_wrap(~component, scales = "free_y") +
  labs(y = NULL, x = "Absolute values of contribution", fill = 'Positive?') 

# for visualization = juice
pca.plot <- juice(pca_prep) %>% # juice() to return the results of a recipe
     #   mutate(Layer = fct_relevel(Layer, c("S", "P"))) %>%
  ggplot(aes(PC1,PC2)) +
#  ggplot(aes(PC1,PC2, label = sample_id)) +
 #  geom_text(aes(label = sample_id),hjust=0, vjust=0) +
  geom_point(aes(color = Depth, shape = site), alpha = 0.7, size = 3) + 
  #geom_text(check_overlap = TRUE, hjust = 'inward', family = 'IBM Plex Sans') +
  geom_hline(yintercept=0, linetype="dashed", alpha = 0.3) +
  geom_vline(xintercept=0, linetype="dashed", alpha = 0.3) +
  # scale_colour_viridis_d(option = "plasma") 
  scale_color_manual(labels = unique(meta$Depth1),values = color_depth) + 
  scale_shape_manual(values=c(15, 18, 17)) +
        theme_Publication_3() +
  theme(legend.position = "none")

# get % variation to add in the legend axis
var_explained <- pca_prep %>%
  tidy(id = 'pca', type = 'variance') %>%
  dplyr::filter(terms == 'percent variance') %>%
  pull(value)

# PCA loading and Scores
# get pca loadings into a wider format
pca_wider <- tidied_pca %>%
  pivot_wider(names_from = component, id_cols = terms) %>%
  mutate(terms = case_when(terms == "PAR" ~ "oxygen, PAR and fluorescence",
                           terms == "NO2" ~ "NH4 and NO2",
                           terms == "PO4" ~ "NOX, conductivity, salinity, \ntemperature and PO4",
                           TRUE ~ as.character(terms)))

# define arrow style
arrow_style <- arrow(length = unit(.05, "inches"),
                     type = "closed")

pca.plot <- pca.plot +
  geom_segment(data = pca_wider,
               aes(xend = PC1*2, yend = PC2*2),
               x = 0, y = 0,
               arrow = arrow_style) +
  geom_text(data = pca_wider,
            aes(x = PC1*2.5, y = PC2*2.5, label = terms),
            hjust = 0.5,
            vjust = 2,
            size = 4,
            color = '#0A537D') +
    # ggrepel::geom_label_repel(data = pca_wider,
    #                           aes(x = PC1*4, y = PC2*4, label = terms), label.size = NA, fill = NA, color = '#0A537D', size = 4) +
  labs(x = paste0(pca.plot$labels$x," ", round(var_explained[1],2),"%"),
       y = paste0(pca.plot$labels$y," ", round(var_explained[2],2),"%"))

pca.plot 

```

```{r env factors - PCA with kmean}
# get PCA socres 
scores.pca <- juice(pca_prep) %>% 
  select(-c(Type,  site, dist_depth, Distance, Depth, Cag_Cont)) %>% 
  column_to_rownames(var = 'sample_id')

# Determine number of clusters using factoextra
# First we will use enhanced k-means clustering
# Enhanced k-means clustering
set.seed(12135)

res.km <- factoextra::eclust(scores.pca, "kmeans", nstart = 25, graph = FALSE)

# compute total within-cluster sum of square (elbow method)
fviz_nbclust(scores.pca, kmeans, method = "wss") +
  theme_Publication()

# Gap statistic plot
fviz_gap_stat(res.km$gap_stat)

# Silhouette plot
fviz_silhouette(res.km)

# k-means clustering [assume 2 clusters]
km <- kmeans(scores.pca, centers= 2, nstart=5)

# add ellipses to PCA plot
k.env <- factor(km$cluster)
pca.env <- pca.plot +  
  stat_ellipse(aes(x=PC1,y=PC2,group=k.env),
               level=0.95, alpha=0.7, type = "norm", linetype = 2) +
        ggtitle("PCA: Environmental variables")

ggsave(paste0(folder_path,"/plots/meta/PCA_env.tiff"), pca.env, compression = "lzw")

#plotly::ggplotly(pca.env)
```


```{r clean R env}
rm(list = setdiff(ls(), c('folder_path','color_distance','color_depth','cage_control','pseq.list',"meta", 'pseq.fun')))
source('~/R/git_hub/MH_2019/script/my_functions.R')
source('~/R/git_hub/MH_2019/script/theme_publication.R')
```



## Community Analysis 

We compared community composition in seawater samples from each depth and distance from the cage. Statistical analysis of ASVs data was conducted principally in R [38] using the Vegan [39], Phyloseq, ggplot2, microbiome and Codaseq packages. 
Gloor et al. argue that microbiome datasets generated by high-throughput sequencing are compositional in nature because the number of DNA sequence reads is limited by the capacity of the sequencing machinery. Thus we analyzed this dataset compositionally by first filtering with CodaSeq (min.reads = 2000, min.occurrence = 0.001, min.prop = 0.001), then conducting a center log-ratio transformation (clr), instead of using standard counts and rarefying.

```{r number of taxa}
pseq.list %>% map_df(., ~ tax_table(.) %>% 
                       as.data.frame() %>%
                       summarise(across(where(is.character), ~n_distinct(.x)))
                     ) %>%
  add_column(Community = names(pseq.list))

```


### Summary tables

```{r asvs}
pseq.list.filt[[2]] %>% 
  summarize_taxa("Phylum") %>% 
  arrange(desc(Abundance))

# Phylum
pseq.list.filt[[2]] %>% 
  summarize_taxa("Phylum", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
  slice_max(freq_by_group, n = 5) 

# Class
pseq.list.filt[[2]] %>% 
  summarize_taxa("Class", GroupBy = "site") %>%
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T)  %>%
  filter(Class != "unknown") %>%
    slice_max(freq_by_group, n = 10) 


# Order
pseq.list.filt[[2]] %>% 
  summarize_taxa("Order", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq.total = str_remove(freq.total, "%"),
         freq.total = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
    slice_max(freq_by_group, n = 5) 

# Family
fam.sel <- pseq.list.filt[[2]] %>% 
  summarize_taxa("Family", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
#    filter(Family != "unknown") %>%
  slice_max(freq_by_group, n = 10) %>% 
  distinct(Family) %>% 
  pull

# Genus
gen.sel <- pseq.list.filt[[2]] %>% 
  summarize_taxa("Genus", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T)  %>%
#   filter(Genus!="unknown") %>% 
    slice_max(freq_by_group, n = 10) %>% 
  distinct(Genus) %>% 
  pull
```

```{r}
# look in more details
pseq.list.filt[[2]] %>%
  get_tibble('tax_table') %>%
  filter(if_any(everything(), ~str_detect(.,"Arcobacteraceae"))) %>% distinct(Genus)

pseq.list.filt[[2]] %>% 
  summarize_by_subtaxa(taxa = "Campylobacteria", Rank = "Genus", GroupBy = "site")  %>%
    select(-Phylum) %>%
  group_by(site) %>% 
  mutate(freq.within.group = str_remove(freq.within.group, "%"),
         freq.within.group = as.numeric(freq.within.group)) %>%
   arrange(desc(freq.within.group), .by_group = T) %>% view
```


```{r picrust}
# all
pseq.func.filt  %>% 
  summarize_taxa("pathway") %>% 
  arrange(desc(Abundance))

# Site
# ontology
pseq.func.filt %>% 
  summarize_taxa("ontology", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
    slice_max(freq_by_group, n = 5) 

# pathway
pseq.func.filt %>% 
  summarize_taxa("pathway", GroupBy = "site") %>%
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T)  %>%
    slice_max(freq_by_group, n = 5)

# description
pseq.func.filt %>% 
  summarize_taxa("description", GroupBy = "site") %>% 
  group_by(site) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T)  %>%
    slice_max(freq_by_group, n = 5)


# Depth
# ontology
pseq.func.filt %>% 
  summarize_taxa("ontology", GroupBy = "Depth") %>% 
  group_by(Depth) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
    slice_max(freq_by_group, n = 5) 

# pathway
pseq.func.filt %>% 
  summarize_taxa("pathway", GroupBy = "Depth") %>% 
  group_by(Depth) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
    slice_max(freq_by_group, n = 5) 

# description
pseq.func.filt %>% 
  summarize_taxa("description", GroupBy = "Depth") %>% 
  group_by(Depth) %>% 
  mutate(freq_by_group = str_remove(freq_by_group, "%"),
         freq_by_group = as.numeric(freq_by_group)) %>%
  arrange(desc(freq_by_group), .by_group = T) %>%
    slice_max(freq_by_group, n = 5) 

```


### Alluvial plot

Alluvial plot showing the total relative abundance distribution of Macquarie Harbour taxa across different taxonomic ranks (class, order, family, and genus) in both cage-influenced areas and control sites.

#### 16s
```{r all}
# https://github.com/adriaaulaICM/bbmo_niche_sea/blob/master/src/figures/abund_prevalence_viz.R
pseq <- pseq.list.filt[[2]]

otu_df <- pseq %>% 
  get_tibble("otu_table", column_id = "ASV")
tax_df <- pseq %>% 
  get_tibble("tax_table", column_id = "ASV")
meta_df <- pseq %>% 
  get_tibble("sam_data", column_id = "sample_id") %>% 
  column_to_rownames("sample_id")

n <- 1+length(levels(as.factor(tax_df$Class)))
my_colors <- friendly_cols[1:n]
taxa <- tax_df %>% distinct(Class) %>% pull
names(my_colors) <- c(taxa, "Other Class")

fam <- tax_df %>%
  mutate_if(is.factor, as.character) %>% 
  filter(Genus %in% gen.sel | Family %in% fam.sel)

selphy <- fam %>% distinct(Phylum) %>% filter(Phylum !="unknown") %>% pull
selclass <- fam  %>% distinct(Class) %>% filter(Class !="unknown") %>% pull
selord <- fam %>% distinct(Order) %>% filter(Order !="unknown") %>% pull

  
df_alluv <- pseq %>% 
  psmelt.dplyr() %>%
  mutate_if(is.factor, as.character) %>% 
  group_by(Phylum, Class, Order, Family, Genus) %>% 
  # filter(!is.na(class)) %>%
  # filter(!is.na(phylum)) %>%
  summarise(value = sum(Abundance)) %>% 
  ungroup() %>% 
  mutate(value = value/sum(value)) %>%
  arrange(Phylum) %>% 
  mutate(Phylum = fct_inorder(Phylum) %>%
           fct_other(keep = selphy, other_level = 'Other Phylum'),
         Class = fct_inorder(Class) %>%
           fct_other(keep = selclass, other_level = 'Other Class'),
         Order = fct_inorder(Order) %>%
           fct_other(keep = selord , other_level = 'Other Order'),
         Family = fct_inorder(Family) %>%
           fct_other(keep = fam.sel, other_level = 'Other Family'),
         Genus = fct_inorder(Genus) %>% 
           fct_other(keep = gen.sel, other_level = 'Other Genus')) %>% 
  select(-Phylum)

paralelldf <- gather_set_data(df_alluv, 1:4) %>% 
  mutate(x = factor(x, levels = c('Class', 'Order',
                                  'Family', 'Genus')))  %>% 
  group_by(y) %>% 
  mutate(total = (sum(value) * 100) %>% round(digits = 1)) %>% 
  mutate(ynew = str_c(y, '; ', total, '%')) %>% 
  filter(!is.na(Genus))  %>% 
  ungroup()   

prettylabs <- paralelldf %>% 
  select(y, ynew) %>% 
  distinct() %>% 
  arrange(y)

paralo <- paralelldf %>%
  mutate_if(is.character, as.factor) %>%
  mutate(y = factor(y, levels = levels(y), labels = prettylabs$ynew))

parallel.plot <- ggplot(paralo , aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = Class),
                     show.legend = F, alpha = 0.6) +
  geom_parallel_sets_labels(angle = 360, size = 3)  + 
  scale_x_discrete(labels = str_to_title) + 
  scale_fill_manual(values = my_colors) +
  theme_Publication_3() + 
  theme(axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.border = element_blank(),
        plot.margin = margin(0, 0, 0, 0, "cm"),
        axis.line.y = element_blank()) + 
  ylab('Total relative abundance (%)') + 
  xlab('Taxonomic rank')

ggsave(parallel.plot, filename = paste0(folder_path, "/plots/community/alluvial_all.tiff"),
       width = 9, height = 8, compression = "lzw")
```

```{r each site}
# make a function
alluvial_plot <- function(pseq, var1, value){

  #set up colors
  tax.df <- pseq %>%
    get_tibble("tax_table")
  
  n <- 1+length(levels(as.factor(tax.df$Class)))
  my_colors <- friendly_cols[1:n]
  taxa <- tax.df %>% distinct(Class) %>% pull
  names(my_colors) <- c(taxa, "Other Class")
  #colScale <- scale_fill_manual(name = "Class",values = my_colors)
  
  to_filt<- pseq %>%
    get_tibble("sam_data") %>%
    filter(.[[var1]] == !!(value)) %>%
    pull(column_id)
  pseq.filt <- prune_samples(to_filt, pseq)
  pseq <- pseq.filt
  
  # extract top 10 taxa
  # Family
  fam.sel <- pseq %>% summarize_taxa("Family") %>% 
     mutate(freq_by_group = str_remove(freq_by_group, "%"),
           freq_by_group = as.numeric(freq_by_group)) %>%
    arrange(desc(freq_by_group), .by_group = T) %>%
    filter(Family != "unknown") %>%
    slice_max(freq_by_group, n = 10) %>% 
    distinct(Family) %>% 
    pull
  
  # Genus
  gen.sel <- pseq %>% summarize_taxa("Genus") %>% 
    mutate(freq_by_group = str_remove(freq_by_group, "%"),
           freq_by_group = as.numeric(freq_by_group)) %>%
    arrange(desc(freq_by_group), .by_group = T)  %>%
    filter(Genus!="unknown") %>% 
    slice_max(freq_by_group, n = 15) %>% 
    distinct(Genus) %>% 
    pull
  
  tax_df <- pseq %>% 
    get_tibble("tax_table", column_id = "ASV")
  
  fam <- tax_df %>%
    mutate_if(is.factor, as.character) %>% 
    filter(Genus %in% gen.sel | Family %in% fam.sel)
  
  selphy <- fam %>% distinct(Phylum) %>% filter(Phylum !="unknown") %>% pull
  selclass <- fam  %>% distinct(Class) %>% filter(Class !="unknown") %>% pull
  selord <- fam %>% distinct(Order) %>% filter(Order !="unknown") %>% pull
  
  df_alluv <- pseq %>% 
    psmelt.dplyr() %>%
    mutate_if(is.factor, as.character) %>% 
    group_by(Phylum, Class, Order, Family, Genus) %>% 
    # filter(!is.na(class)) %>%
    # filter(!is.na(phylum)) %>%
    summarise(value = sum(Abundance)) %>% 
    ungroup() %>% 
    mutate(value = value/sum(value)) %>%
    arrange(Phylum) %>% 
    mutate(Phylum = fct_inorder(Phylum) %>%
             fct_other(keep = selphy, other_level = 'Other Phylum'),
           Class = fct_inorder(Class) %>%
             fct_other(keep = selclass, other_level = 'Other Class'),
           Order = fct_inorder(Order) %>%
             fct_other(keep = selord , other_level = 'Other Order'),
           Family = fct_inorder(Family) %>%
             fct_other(keep = fam.sel, other_level = 'Other Family'),
           Genus = fct_inorder(Genus) %>% 
             fct_other(keep = gen.sel, other_level = 'Other Genus')) %>% 
    select(-Phylum)
  
  paralelldf <- gather_set_data(df_alluv, 1:4) %>% 
    mutate(x = factor(x, levels = c('Class', 'Order',
                                    'Family', 'Genus')))  %>% 
    group_by(y) %>% 
    mutate(total = (sum(value) * 100) %>% round(digits = 1)) %>% 
    mutate(ynew = str_c(y, '; ', total, '%')) %>% 
    filter(!is.na(Genus))  %>% 
    ungroup()   
  
  prettylabs <- paralelldf %>% 
    select(y, ynew) %>% 
    distinct() %>% 
    arrange(y)
  
  paralo <- paralelldf %>%
    mutate_if(is.character, as.factor) %>%
    mutate(y = factor(y, levels = levels(y), labels = prettylabs$ynew))
  
  # plot
  parallel.plot <- ggplot(paralo , aes(x, id = id, split = y, value = value)) +
    geom_parallel_sets(aes(fill = Class),
                       show.legend = F, alpha = 0.6) +
    geom_parallel_sets_labels(angle = 360, size = 3)  + 
    scale_x_discrete(labels = str_to_title) + 
    scale_fill_manual(values = my_colors) +
    theme_Publication_3() + 
    theme(axis.text.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.border = element_blank(),
          plot.margin = margin(0, 0, 0, 0, "cm"),
          axis.line.y = element_blank()) + 
    ylab('Total relative abundance (%)') + 
    xlab('Taxonomic rank') +
    ggtitle(glue::glue("{value}"))
  
  return(parallel.plot)

}

all_control <- pseq.list.filt[[2]] %>% 
  subset_samples(site == "Control") %>% 
  alluvial_plot("site", "Control")
all_cage1 <- pseq.list.filt[[2]] %>%
  subset_samples(site == "lease_1") %>% 
  alluvial_plot("site", "lease_1")
all_cage2 <-  pseq.list.filt[[2]] %>%
  subset_samples(site == "lease_2") %>% 
  alluvial_plot("site", "lease_2")

alluvial_plot_site <- all_control / all_cage1 / all_cage2 

ggsave(alluvial_plot_site, filename = paste0(folder_path, "/plots/community/alluvial_sites.tiff"),
       width = 10, height = 15, compression = "lzw")

```

### Bar plot

#### picrust
```{r all}
# https://github.com/adriaaulaICM/bbmo_niche_sea/blob/master/src/figures/abund_prevalence_viz.R
pseq <- pseq.func.filt

# pseq.func.filt %>% 
#   microbiome::transform("compositional") %>%
#   bar_plot_taxa(taxo = "ontology")

bar_plot_func <- pseq.func.filt %>% 
  microbiome::transform("compositional") %>% 
  bar_plot_taxa_group(taxo = "pathway", grouping_column = "site")

bar_plot_func <- bar_plot_func + theme(legend.position = "bottom",
                      legend.text = element_text(size = 12))


ggsave(bar_plot_func, filename = paste0(folder_path, "/plots/community/bar_plot_picrust.tiff"),
       width = 16, height = 10, compression = "lzw")

```



### PCA

```{r Exploratory PCA}
pca_pseq <- function(x,...){
pseq <- x
clr_otu <- otu_table(pseq)
# CoDaSeq::codaSeq.outlier(t(clr_otu))
ord_meta <- pseq %>% get_tibble("sam_data", column_id = "sample_id")
King <- unique(data.frame(tax_table(pseq)[,1]))
Y <- as.data.frame(t(clr_otu)) 

pca_fit <- Y %>% 
  scale %>% 
  prcomp() 

var <- pca_fit %>% 
  tidy(matrix = "eigenvalues")

p.pca <- pca_fit %>%
  augment() %>%
  rename("sample_id" = 1) %>%
  left_join(ord_meta) %>%
  rename_with(~str_replace(.,".fitted","")) %>%
  ggplot(aes(PC1, PC2, color = Depth)) + 
  geom_point(aes(color = Depth, shape = site), alpha = 0.7, size =3) + 
  #geom_text(check_overlap = TRUE, hjust = 'inward', family = 'IBM Plex Sans') +
  geom_hline(yintercept=0, linetype="dashed", alpha = 0.3) +
  geom_vline(xintercept=0, linetype="dashed", alpha = 0.3) +
  labs(x = paste("PC1", round(var$percent[1]*100,2), "%"),
       y = paste("PC2", round(var$percent[2]*100,2), "%")) +
  # scale_colour_viridis_d(option = "plasma") 
  scale_color_manual(labels = unique(ord_meta$Depth1),values = color_depth) + 
  scale_shape_manual(values=c(15, 18, 17)) +
  ggtitle(King)

return(p.pca)
}

# clr transformed
clr.pca <- pseq.list.clr %>% map(pca_pseq)
clr.pca.16s <- clr.pca %>% keep(names(.) %in% c("Bacteria", 'Archaea'))
# picrust
func.pca <- pca_pseq(pseq.func.clr) + ggtitle("Function")

# dir.create(paste0(folder_path, "plots/community"))

clr.pca.all.16s <- wrap_plots(clr.pca.16s) +
  plot_layout(guides='collect')  &
  theme(legend.position='bottom')

ggsave(paste0(folder_path, "plots/community/pca.16s.tiff"),clr.pca.all.16s, compression = "lzw")
ggsave(paste0(folder_path, "plots/community/pca.picrust.tiff"),func.pca, compression = "lzw")

```

### Hierarquical Clustering

```{r EDA hcluster}
# hierarchical clustering
# Aitchison distance = Euclidean distance of clr-transformed compositions
# generate the distance matrix
taxdf <- pseq.list.clr[[2]] %>% 
  get_tibble("tax_table") %>% 
  distinct(Phylum) %>% pull

pseq <- pseq.list.clr[[2]] %>% 
  subset_taxa(Phylum == "Chloroflexi") 
#  pseq <- pseq.func %>% transform("clr")
df <- pseq %>% abundances()
dd <- dist(t(df), method="euclidian")
# cluster the data
hc <- hclust(dd, method="ward.D2")
# str(hc)
# Cluster plot
plot(hc, cex=0.6)
# generate colors
library(scales)
n1 <- 5                                        # Amount of default colors
hex_codes1 <- hue_pal()(n1)                             # Identify hex codes
#show_col(hex_codes1)

# plot using the optimal number of clusters found in the k-mean cluster
clust1 <- factoextra::fviz_dend(hc, cex = 0.8, k= 6, palette = c("darkblue","#A3A500","darkgreen","#00B0F6","#dd00f6","darkred"), 
                    rect = TRUE, rect_border = c("darkblue","#A3A500","darkgreen","#00B0F6","#dd00f6","darkred"), rect_fill = TRUE, 
                    main = "Dendrogram - ward.D2",
                    xlab = "Samples", ylab = "Distance", sub = "") +
  theme_Publication_1() +
  theme(panel.border = element_blank())

```

### db-RDA

ordistep, VIF and envfit used to select the env variables
```{r RDA}
load("pseq.list.clr.RData") 
load("pseq.func.clr.RData")

pseq <- pseq.list.clr[[2]]

# prepare the data
rda.pseq <- function(pseq){
  set.seed(123)
tax_df <- pseq %>% get_tibble("tax_table", column_id = "ASV") 
# King <- tax_df %>% distinct(Kingdom) %>% pull
clr_asv <- pseq %>% 
    get_tibble("otu_table", column_id = "ASV") %>% 
    column_to_rownames('ASV')
meta <- pseq %>% 
    get_tibble("sam_data", column_id = "sample_id")
ord_meta <- meta %>%
    select(sample_id, NH4, NOX, turbidity, oxygen) %>% 
    column_to_rownames("sample_id")
  
# cond <- apply(ord_meta, 2, function(x) any(is.na(x))) # check for NAs
X <- ord_meta %>% select(where(~is.numeric(.) && all(!is.na(.))))
X <- vegan::decostand(X, method='standardize')
Y <- as.data.frame(t(clr_asv)) 
  
# RDA
# res <- rda(Y ~ ., data=X)
# plot(res, xlab=QsRutils::ord_labels(res)[1], ylab=QsRutils::ord_labels(res)[2])
  
# dbRDA 
# note the result is the same as for RDA when using euclidean distances
# res <- capscale(Y ~ ., data=X, distance='euclidean')
# plot(res, xlab=QsRutils::ord_labels(res)[1], ylab=QsRutils::ord_labels(res)[2])

# select only the variables that are explaining variation efficiently.

# calculate variance inflation factors (VIF)
# variables with scores >10 are redundant
# sort(vif.cca(res))
  
# Fitting environmental vectors/factors onto an ordination 
# calculate fit
bio.fit <- envfit(Y ~ ., data=X)
  
# Stepwise selection (ordistep)
# set up full and null models for 'ordistep'
# full model
rda1 <- rda(Y ~ ., data=X)
# intercept-only (null) model
rda0 <- rda(Y ~ 1, data=X)
  
# perform forward and backward selection of explanatory variables
# output not shown
step.env <- ordistep(rda0, Pin = 0.01, scope=formula(rda1), direction='both')
  
# look at the significant variables 
#step.env$anova
# For the sake of argument, let’s include the variables
# with low VIF scores along with those identified by ordistep.
# code to get variable names from 'ordistep' and 'envfit' results
# make a dataframe with pvalues and envpars
vars.df <- data.frame(step.env$anova) %>% 
    rownames_to_column("env_par") %>%
    mutate(env_par = str_trim(str_replace(env_par, "[+]", ""))) %>% 
    # mutate(env_par = str_replace(env_par, "\"", "")) %>% 
    rename(p_value.ordistep = Pr..F.) %>% 
    select(env_par,p_value.ordistep) %>% 
    full_join(data.frame(bio.fit$vectors$pvals) %>% filter(. <=0.01) %>%
                rename(p_value.env.fit = bio.fit.vectors.pvals) %>%
                rownames_to_column("env_par")
    ) %>%
    full_join(as.data.frame(vif.cca(res)) %>% filter(. <=10) %>%
                rename(vif.score = 'vif.cca(res)') %>%
                rownames_to_column("env_par")
    ) %>%
    full_join(bio.fit[["vectors"]][["r"]] %>% data.frame() %>% 
                rename(r_envfit = '.') %>%
                rownames_to_column("env_par") %>%
                mutate(r_envfit = round(r_envfit,2))
    )

# get the variables to use in the next steps of the analysis
vars <- vars.df %>% 
  filter(p_value.ordistep < 0.01 & p_value.env.fit < 0.01) %>% 
  pull(env_par)

# write_csv(vars.df, paste0(folder_path, "data/db-RDA_bacteria.csv"))  
#vars 
# select variables to keep from table 'Y'
X1 <- X %>% select(matches(vars))
#str(X1)
  
# RDA
res <- rda(Y ~ ., data=X1)
  
  # summary of the results
  # summary(res, display=NULL)
  # permutation test of statistical significance
  # anova(res)
  
  # plotting
  # load library
  
# set up dataframes for plotting the results
sit <- meta %>%
    left_join(vegan::scores(res, 
                            display='sites', choices=c(1:2)) %>%
                as.data.frame() %>%
                rownames_to_column("sample_id")) %>%
  column_to_rownames("sample_id")

spp <- tax_df %>% 
    left_join(vegan::scores(res, display='species') %>% 
                data.frame() %>% 
                rownames_to_column('ASV')) %>%
                column_to_rownames("ASV")
vec <- vegan::scores(res, display='bp') %>% 
    data.frame() %>%
    rownames_to_column("terms") %>%
    mutate(terms = case_when(terms == "oxygen" ~ "oxygen, PAR and fluorescence",
                           terms == "NH4" ~ "NH4 and NO2",
                           terms == "NOX" ~ "NOX, conductivity, salinity, \ntemperature and PO4",
                           TRUE ~ as.character(terms))) 
  
  # use these to adjust length of arrows and position of arrow labels
  adj.vec <- 2
  adj.txt <- 2.5
  arrow_style <- arrow(length = unit(.05, "inches"),
                       type = "closed")
  
  # 'site' ordination
p1 <- sit %>%
    rownames_to_column("sample_id") %>%
    ggplot(aes(x=RDA1, y=RDA2, label = sample_id)) +
    geom_point(aes(color = Depth, shape = site) , size= 3,alpha = 0.5) +
    geom_segment(data = vec,
                 inherit.aes=F,
                 mapping=aes(x=0, y=0, 
                             xend=adj.vec*RDA1, 
                             yend=adj.vec*RDA2),
                 arrow = arrow_style,
                 alpha = 0.4) +
      ggrepel::geom_text_repel(data=vec,
              mapping=aes(x=adj.txt*RDA1, y=adj.txt*RDA2,
                          label=terms), 
              hjust = 0,
              vjust = 0.65,
              size = 4.2,
              alpha = 0.9,
              color = '#0A234E') +
  #  ggtitle(paste0('dbRDA: ',King)) +
    scale_color_manual(labels = unique(meta$Depth1),values = color_depth) + 
    scale_shape_manual(values=c(15, 18, 17)) +
    geom_hline(yintercept=0, linetype="dashed", alpha = 0.3) +
    geom_vline(xintercept=0, linetype="dashed", alpha = 0.3) +
    #labs(colour = GroupBy)+ #another way to set the labels, in this case, for the colour legend
    labs(x = QsRutils::ord_labels(res)[1],
         y = QsRutils::ord_labels(res)[2]) +
    theme(legend.position = 'bottom') 


return(list(p1, vars.df))

}


rda.bac <- rda.pseq(pseq.list.clr[[2]])
rda.bac.plot <- rda.bac[[1]] + ggtitle(paste0('dbRDA: Bacteria'))
write_csv(rda.bac[[2]], paste0(folder_path, "data/db-RDA_bacteria.csv")) 
rda.func <- rda.pseq(pseq.func.clr)
rda.func.plot <- rda.func[[1]] + ggtitle(paste0('dbRDA: Functional Annotations'))
write_csv(rda.func[[2]], paste0(folder_path, "data/db-RDA_picrust.csv"))

```


### Mantel test

```{r mantel}
pseq <- pseq.list.clr[[2]]

mantel_func <- function(pseq, title){

asv_clr <- pseq %>% 
  get_tibble("otu_table", column_id = "ASV") %>% 
  column_to_rownames("ASV")
meta.mantel <-  pseq %>% 
  get_tibble("sam_data", column_id = "sample_id") %>% 
  column_to_rownames("sample_id")
#abundance data frame
abund = data.frame(t(asv_clr)) # SAMPLES as ROWS !!!!!
#abundance data frame - bray curtis dissimilarity
dist.abund = dist(abund, method = "euclidean")
#make subset
env = meta.mantel %>% 
  dplyr::select(NH4, NOX, oxygen, turbidity)
#scale data 
scale.env = scale(env, center = TRUE, scale = TRUE)
#create distance matrix of scaled data
dist.env = dist(scale.env, method = "euclidean")

#longitude and latitude 
geo = meta.mantel %>% select(long, lat)
#geographic data frame - haversine distance 
d.geo = geosphere::distm(geo, fun = geosphere::distHaversine)
dist.geo = as.dist(d.geo)

#run mantel test 
#abundance vs environmental
abund_env = mantel(dist.abund, dist.env, method = "spearman", permutations = 9999, na.rm = TRUE)
abund_env
#abundance vs geographic 
abund_geo  = mantel(dist.abund, dist.geo, method = "spearman", permutations = 9999, na.rm = TRUE)
abund_geo
# environmental vs geographic
env_geo  = mantel(dist.env, dist.geo, method = "spearman", permutations = 9999, na.rm = TRUE)
env_geo

# Partial Mantel tests
# geo distance controlled
# We will do that while removing any possible spatial autocorrelation.
abund_partial_envgeo = mantel.partial(dist.abund, dist.env, dist.geo, method = "spearman", permutations = 9999, na.rm = TRUE)
abund_partial_envgeo
# env variability controlled
abund_partial_geoenv  = mantel.partial(dist.abund,  dist.geo, dist.env,method = "spearman", permutations = 9999, na.rm = TRUE)
abund_partial_geoenv   

df <- tibble(test = c('abund_env', 'abund_geo', 'env_geo', "partial_ab_env_by_geo", "partial_ab_geo_by_env"),
          rho = c(abund_env$statistic, abund_geo$statistic, env_geo$statistic,abund_partial_envgeo$statistic, abund_partial_geoenv$statistic),
          p_value = c(abund_env$signif, abund_geo$signif, env_geo$signif, abund_partial_envgeo$signif,abund_partial_geoenv$signif))

# Pairwise scatter plots
aa = as.vector(dist.abund)
tt = as.vector(dist.env)
gg =  as.vector(dist.geo)

#new data frame with vectorized distance matrices
mat = data.frame(aa,tt,gg)

#abundance vs env paramters
lm = lm(aa~tt, data = mat)
summary(lm)
my.formula <- aa~tt

ab_env <- ggplot(mat, aes(y = aa, x = tt)) + 
  geom_point(size = 2.5, alpha = 0.3) + 
  labs(x = "Difference in Env Factors", y = "Euclidean Distance") + 
  geom_smooth(method = 'lm', color = "orange", alpha = 0.3, se = F)  +
  # show rho and p.value
  ggpubr::stat_cor(method = "spearman",
                   cor.coef.name = "rho",
                   aes(label = paste(..r.label.., ..p.label.., sep = "~`,`~"))) +
  ggtitle(glue::glue("{title}"))

#abundance vs geo dist
lm = lm(aa~gg, data = mat)
summary(lm)
my.formula <- aa~gg

#new data frame with vectorized distance matrices
ab_geo <- ggplot(mat, aes(y = aa, x = gg/1000)) + 
  geom_point(size = 2.5, alpha = 0.3) + 
  labs(x = "Physical Distance (km)", y = "Euclidean Distance") + 
  geom_smooth(method = 'lm', color = "orange", alpha = 0.3, se = F)  +
  # show rho and p.value
  ggpubr::stat_cor(method = "spearman",
                   cor.coef.name = "rho",
                   aes(label = paste(..r.label.., ..p.label.., sep = "~`,`~"))) +
  ggtitle(glue::glue("{title}"))


return(list(df, ab_env, ab_geo))

}

# all depths
mantel1 <- pseq %>%  
  mantel_func("all samples") 

# DP1
mantel2 <- pseq %>% 
  subset_samples(Depth == "DP1") %>% 
  mantel_func("Surface")
# DP2
mantel3 <- pseq %>% subset_samples(Depth == "DP2") %>% 
  mantel_func("Middle layers")
# DP3
mantel4 <- pseq %>% subset_samples(Depth == "DP3") %>% 
  mantel_func("Bottom waters") 

df_mantel <- bind_rows(mantel1[[1]] %>% add_row(test = "all",.before = 1), 
          mantel2[[1]] %>% add_row(test = "surface",.before = 1), 
          mantel3[[1]] %>% add_row(test = "middle",.before = 1), 
          mantel4[[1]] %>% add_row(test = "bottom",.before = 1))

write_csv(df_mantel, paste0(folder_path,"data/mantel.csv"))

mantel_plots <- (mantel1[[3]] + theme(axis.title.x = element_blank()) + mantel2[[3]] + theme(axis.title.y = element_blank(), axis.title.x = element_blank())) / (mantel3[[3]] + mantel4[[3]] + theme(axis.title.y = element_blank()))

mantel_plots1 <- (mantel1[[2]] + theme(axis.title.x = element_blank()) + mantel2[[2]] + theme(axis.title.y = element_blank(), axis.title.x = element_blank())) / (mantel3[[2]] + mantel4[[2]] + theme(axis.title.y = element_blank()))

# ylab <- mantel1$labels$y
# xlab <- mantel3$labels$x
# mantel1$labels$y <- mantel3$labels$y <- " "
# mantel3$labels$x <- mantel4$labels$x <- " "

# mantel_plots <- (mantel1 + mantel2) / (mantel3 + mantel4)
# grid::grid.draw(grid::textGrob(ylab, x = 0.02, rot = 90))
# grid::grid.draw(grid::textGrob(xlab, y = 0.02, rot = 360))

ggsave(paste0(folder_path,"/plots/community/mantel_bac_distgeo.tiff"), mantel_plots, compression = "lzw")

ggsave(paste0(folder_path,"/plots/community/mantel_bac_env.tiff"), mantel_plots1, compression = "lzw")


# Mantel test (mantel_test.R)
# https://jkzorz.github.io/2019/07/08/mantel-test.html


```

### Mantel test (16s vs picrust)

```{r}
# Tristan Cordier et al, 2019. Bacterial communities’ taxonomic and functional turnovers
# both accurately predict marine benthic ecological quality status

asv_clr <- pseq.list.clr[[2]] %>% 
  get_tibble("otu_table", column_id = "ASV") %>% 
  column_to_rownames("ASV")

fun_clr <- pseq.func.clr  %>% 
  get_tibble("otu_table", column_id = "ASV") %>% 
  column_to_rownames("ASV")

#abundance data frame
abund = data.frame(t(asv_clr)) # SAMPLES as ROWS !!!!!
#abundance data frame - bray curtis dissimilarity
abund = scale(abund, center = T, scale = T)
dist.abund = dist(abund, method = "euclidean")

#picrust data frame
func = data.frame(t(fun_clr)) # SAMPLES as ROWS !!!!!
#create distance matrix of scaled data
func  = scale(func , center = T, scale = T)
dist.func = dist(func, method = "euclidean")

#run mantel test 
#abundance vs environmental
abund_func = mantel(dist.abund, dist.func, method = "spearman", permutations = 9999, na.rm = TRUE)
abund_func 

# Pairwise scatter plots
asv_abund = as.vector(dist.abund)
funct = as.vector(dist.func)

#new data frame with vectorized distance matrices
mat = data.frame(asv_abund,funct)

#abundance vs env paramters
# lm = lm(asv_abund~funct, data = mat)
# summary(lm)

ab_func <- ggplot(mat, aes(y = log10(asv_abund), x = log10(funct))) + 
  geom_point(size = 2.5, alpha = 0.3) + 
  labs(x = "Difference in function", 
       y = "Difference in composition") + 
  # geom_smooth(method = 'lm', color = "orange", alpha = 0.3, se = F)  +
  geom_abline(intercept = 0, slope = 1,
                 color = "red") +
  annotate(geom = "text", 
           label = paste0('\u03C1 = ',round(abund_func$statistic,3)," p = ", abund_func$signif), 
           x=0.12, 
           y=2) + 
  xlim(0, 2.15) + 
  ylim(0, 2.15) +
  theme(panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())

ggsave(paste0(folder_path,"/plots/community/mantel_bac_picrust.tiff"), ab_func, compression = "lzw")
```

```{r}
all_ord <- (pca.env + plot_layout(guides = "collect") & theme(legend.position = "bottom")) +  (rda.bac.plot + theme(legend.position = "none")) +  (rda.func.plot + theme(legend.position = "none"))  + ab_func + plot_annotation(tag_levels = "A") &
  guides(color = guide_legend(nrow = 2), shape = guide_legend(nrow = 2))


ggsave(all_ord, filename =  paste0(folder_path,"plots/community/pca_db-RDA_mantel_bac_picrust.tiff"), compression = "lzw", height = 11.3, width = 17.8)
```

# AOB and NOB 
```{r}
df <- pseq.list.clr[[2]] %>% 
  psmelt.dplyr()  %>%
  filter(if_any(everything(), ~str_detect(.,"Nitrospirota"))) %>%
#  filter(if_any(everything(), ~str_detect(.,"Nitrosomonas"))) %>%
#  filter(if_any(everything(), ~str_detect(.,"Nitrosomonadaceae"))) %>%
 #  filter(if_any(everything(), ~str_detect(.,"Nitrospina"))) %>%
  rename(ASV = OTU)

df %>%
  filter(site == "lease_1") %>%
  mutate(ASV = factor(ASV),
         Distance_m = round(Distance_m, 1),
         Distance_m = as.factor(Distance_m)) %>%
  mutate(ASV = str_c(ASV, Phylum, Class, Order, Family, sep = "_"),
         ASV = str_remove(ASV, "e_asv_")) %>%
  ggplot(aes(x = Distance_m, y = Abundance, group = Depth1)) + 
  geom_jitter(aes(color = Depth1),
              alpha = 0.6,
              show.legend = T, 
              width = 0.1) + 
  #    geom_line(aes(linetype = Depth, color = Depth)) +
  stat_smooth(aes(color = Depth1),
           #   method = 'gam',
              se = F, size = 1,
              show.legend = F, alpha = 0.3) +
      labs(y = "Abundance (clr)",
       title = paste(unique(df$Phylum), " lease 1")) +
  # labs(y = "Abundance (clr)",
  #      title = paste("Nitrosomonadaceae - lease 1")) +
  facet_wrap(~Genus, scales = "free")

df %>%
  filter(site == "lease_2") %>%
  mutate(ASV = factor(ASV),
         Distance_m = round(Distance_m, 1),
         Distance_m = as.factor(Distance_m)) %>%
  mutate(ASV = str_c(ASV, Phylum, Class, Order, Family, sep = "_"),
         ASV = str_remove(ASV, "e_asv_")) %>%
  ggplot(aes(x = Distance_m, y = Abundance, group = Depth1)) + 
  geom_jitter(aes(color = Depth1),
              alpha = 0.6,
              show.legend = T, 
              width = 0.1) + 
  #    geom_line(aes(linetype = Depth, color = Depth)) +
  stat_smooth(aes(color = Depth1),
           #   method = 'gam',
              se = F, size = 1,
              show.legend = F, alpha = 0.3) +
    labs(y = "Abundance (clr)",
       title = paste0(unique(df$Phylum), " lease 2")) +
  # labs(y = "Abundance (clr)",
  #      title = paste("Nitrosomonadaceae - lease 2")) +
  facet_wrap(~Genus, scales = "free")

```


```{r}
df <- pseq.list.clr[[2]] %>% 
  # microbiome::transform("compositional") %>%
  psmelt.dplyr()  %>%
 filter(if_any(everything(), ~str_detect(.,"Nitrospirota"))) %>%
  rename(ASV = OTU)
  

plot1 <- df %>%
  filter(site != "lease_2") %>%
  mutate(ASV = factor(ASV),
         Distance_m = round(Distance_m, 1),
         Distance_m = as.factor(Distance_m)) %>%
  mutate(ASV = str_c(ASV, Phylum, Class, Order, Family, sep = "_"),
         ASV = str_remove(ASV, "e_asv_")) %>%
  ggplot(aes(x = Distance_m, y = Abundance, group = Depth1)) + 
  geom_jitter(aes(color = Depth1),
              alpha = 0.6,
              show.legend = T, 
              width = 0.1) + 
  #    geom_line(aes(linetype = Depth, color = Depth)) +
  stat_smooth(aes(color = Depth1),
           #   method = 'gam',
              se = F, size = 1,
              show.legend = F, alpha = 0.3) +
   geom_vline(xintercept="82.8", linetype="dashed", 
                color = "red", size=0.5, alpha = 0.5) +
#   scale_y_continuous(labels = percent) +
   labs(y = "Abundance (clr)",
        title = paste0(unique(df$Phylum)," lease 1")) +
  facet_wrap(~Genus, scales = "free")

plot2 <- df %>%
  filter(site != "lease_1") %>%
  mutate(ASV = factor(ASV),
         Distance_m = round(Distance_m, 1),
         Distance_m = as.factor(Distance_m)) %>%
  mutate(ASV = str_c(ASV, Phylum, Class, Order, Family, sep = "_"),
         ASV = str_remove(ASV, "e_asv_")) %>%
  ggplot(aes(x = Distance_m, y = Abundance, group = Depth1)) + 
  geom_jitter(aes(color = Depth1),
              alpha = 0.6,
              show.legend = T, 
              width = 0.1) + 
  #    geom_line(aes(linetype = Depth, color = Depth)) +
  stat_smooth(aes(color = Depth1),
           #   method = 'gam',
              se = F, size = 1,
              show.legend = F, alpha = 0.3) +
   geom_vline(xintercept="84.2", linetype="dashed", 
                color = "red", size=0.5, alpha = 0.5) +
 #  scale_y_continuous(labels = percent) +
   labs(y = "Abundance (clr)",
        title = paste0(unique(df$Phylum), " lease 2")) +
  facet_wrap(~Genus, scales = "free")

plot1 / plot2 +  plot_layout(guides='collect') &
  theme(legend.position='bottom')

```

